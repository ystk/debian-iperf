Description: iperf forks and loops endlessly in daemon mode
 Reported by: Ken Sharp
 When initially launched in daemon (-D) mode, iperf will sit quietly and
 wait. However, once a test is performed iperf forks a new thread and
 this process never exits and continues to run at 100% CPU until it is
 killed.
 .
 The problem was caused by starting a thread and then forking the program
 as part of daemonizing it. This resulted in the thread no longer
 communicating correctly with the forked main program. See here for more
 information:
 http://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them
Forwarded: https://sourceforge.net/p/iperf/patches/28/
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1260893
Author: Roderick Smith <rod.smith@canonical.com>

Index: iperf-2.0.5+dfsg1/src/Listener.cpp
===================================================================
--- iperf-2.0.5+dfsg1.orig/src/Listener.cpp	2014-07-13 21:21:34.000000000 +0200
+++ iperf-2.0.5+dfsg1/src/Listener.cpp	2014-07-13 22:21:49.733157309 +0200
@@ -675,40 +675,7 @@
  * --------------------------------------------------------------------*/ 
 
 void Listener::runAsDaemon(const char *pname, int facility) {
-#ifndef WIN32 
-    pid_t pid; 
-
-    /* Create a child process & if successful, exit from the parent process */ 
-    if ( (pid = fork()) == -1 ) {
-        fprintf( stderr, "error in first child create\n");     
-        exit(0); 
-    } else if ( pid != 0 ) {
-        exit(0); 
-    }
-
-    /* Try becoming the session leader, once the parent exits */
-    if ( setsid() == -1 ) {           /* Become the session leader */ 
-        fprintf( stderr, "Cannot change the session group leader\n"); 
-    } else {
-    } 
-    signal(SIGHUP,SIG_IGN); 
-
-
-    /* Now fork() and get released from the terminal */  
-    if ( (pid = fork()) == -1 ) {
-        fprintf( stderr, "error\n");   
-        exit(0); 
-    } else if ( pid != 0 ) {
-        exit(0); 
-    }
-
-    chdir("."); 
-    fprintf( stderr, "Running Iperf Server as a daemon\n"); 
-    fprintf( stderr, "The Iperf daemon process ID : %d\n",((int)getpid())); 
-    fflush(stderr); 
-
-    fclose(stdin); 
-#else 
+#ifdef WIN32
     fprintf( stderr, "Use the precompiled windows version for service (daemon) option\n"); 
 #endif  
 
Index: iperf-2.0.5+dfsg1/src/main.cpp
===================================================================
--- iperf-2.0.5+dfsg1.orig/src/main.cpp	2010-03-31 01:08:24.000000000 +0200
+++ iperf-2.0.5+dfsg1/src/main.cpp	2014-07-13 21:21:34.000000000 +0200
@@ -109,6 +109,47 @@
 // for all other threads to complete
 void waitUntilQuit( void );
 
+/* --------------------------------------------------------------------
+ * Run the server as a daemon
+ * --------------------------------------------------------------------*/
+
+static void runAsDaemon( void ) {
+#ifndef WIN32
+    pid_t pid;
+
+    /* Create a child process & if successful, exit from the parent process */
+    if ( (pid = fork()) == -1 ) {
+        fprintf( stderr, "error in first child create\n");
+        exit(0);
+    } else if ( pid != 0 ) {
+        exit(0);
+    }
+
+    /* Try becoming the session leader, once the parent exits */
+    if ( setsid() == -1 ) {           /* Become the session leader */
+        fprintf( stderr, "Cannot change the session group leader\n");
+    } else {
+    }
+    signal(SIGHUP,SIG_IGN);
+
+
+    /* Now fork() and get released from the terminal */
+    if ( (pid = fork()) == -1 ) {
+        fprintf( stderr, "error\n");
+        exit(0);
+    } else if ( pid != 0 ) {
+        exit(0);
+    }
+
+    chdir(".");
+    fprintf( stderr, "Running Iperf Server as a daemon\n");
+    fprintf( stderr, "The Iperf daemon process ID : %d\n",((int)getpid()));
+    fflush(stderr);
+
+    fclose(stdin);
+#endif
+}
+
 /* -------------------------------------------------------------------
  * main()
  *      Entry point into Iperf
@@ -188,6 +229,9 @@
             }
         }
 #endif
+        if ( isDaemon( ext_gSettings ) ) {
+            runAsDaemon();
+        }
         // initialize client(s)
         if ( ext_gSettings->mThreadMode == kMode_Client ) {
             client_init( ext_gSettings );
